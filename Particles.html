<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <canvas id="particleCanvas" width="400" height="400"></canvas>
    <table>
        <tr>
            <td>Windspeed (-5 to 5):</td>
            <td><input type="range" min="-5" max="5" value="0" class="slider" id="speed"></span></td>
        </tr>
        <tr>
            <td>Particle Density (1% to 100%):</td>
            <td><input type="range" min="1" max="100" value="80" class="slider" id="density"></td>
        </tr>
        <tr>
            <td>Gravity (1x to 10x)</td>
            <td><input type="range" min="1" max="10" value="1" class="slider" id="gravity"></td>
        </tr>
    </table>
    <script>

        var cvs = document.getElementById("particleCanvas");
        var windSpeed = document.getElementById("speed");
        var density = document.getElementById("density");
        var gravity = document.getElementById("gravity");
        var ctx = cvs.getContext("2d");

        //Array that will contain all particles on the screen
        var particles = {}, particleID = 0
        particleType = "Snow"; //Default to snowing

        //Array that will contain all buttons on the screen
        var buttons = {}, buttonID = 1; //Initialize to 1 for button X placement calculation

        function Particle() {

            //Future Todo: abstract this out rather than hard-code in function?
            switch (particleType) {
                case "Snow":
                    this.x = Math.floor(Math.random() * cvs.width);
                    this.y = 0;
                    this.XDir = (Math.random() * 2) >= 1 ? 1 : -1;                                      //positive-x/negative-x movement
                    this.size = (Math.random() * 5);                                                    //Particle size
                    this.colorR = 175 + (Math.ceil(this.size) * 20);
                    this.colorG = this.colorR;
                    this.colorB = this.colorR;
                    this.colorVal = "rgb(" + this.colorR + "," + this.colorG + "," + this.colorB + ")"; //Smaller particles = darker
                    this.gravity = 0.5;
                    this.shape = "Round";
                    this.speed = (Math.floor(Math.random() * this.size) / 5);//Horizontal speed
                    break;
                case "Rain":
                    this.x = Math.floor(Math.random() * cvs.width);
                    this.y = 0;
                    this.XDir = 0;
                    this.size = (Math.random() * 3);
                    this.colorVal = "rgb(35,35," + 105 + (Math.ceil(this.size) * 20); + ")";
                    this.gravity = 5;
                    this.shape = "Rect";
                    this.speed = 0;
                    break;
            }

            //Particle knows its type and starting position
            this.type = particleType;
            this.initialX = this.x;

            particles[particleID++] = this;

            //Draw function is abstract, and offers two Shape choices - Round/Rect
            this.draw = function () {
                this.y += (this.gravity * gravity.value);

                //horizontal movement
                if (this.x >= 50 + this.initialX) {
                    this.XDir = -1;
                }
                else if (this.x <= this.initialX - 50) {
                    this.XDir = 1;
                }


                this.x += (this.speed * this.XDir);

                if (this.shape == "Round") {
                    if (speed.value != 0) {
                        this.x = this.x + (gravity.value * .5 * (speed.value / 5));
                    }
                    ctx.beginPath();
                    ctx.fillStyle = this.colorVal;
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.fill();

                } else if (this.shape == "Rect") {
                    if (speed.value != 0) {
                        this.x = this.x + (gravity.value * .5 * (speed.value / 2.5));

                        //Raindrops are heavier at the bottom, simulate wind effect on the entire raindrop
                        ctx.fillRect(this.x, this.y, this.size, (this.size));
                        ctx.fillRect((this.x - (gravity.value * .5 * speed.value / 2.5)), (this.y - this.size), this.size, (this.size));
                        ctx.fillRect((this.x - 2 * (gravity.value * .5 * speed.value / 2.5)), (this.y - (2 * this.size)), this.size, (this.size));

                    } else {
                        //No wind - normal rectangle raindrops (3 units long)
                        ctx.fillRect(this.x, this.y, this.size, (this.size * 3));
                    }
                    ctx.fillStyle = this.colorVal;
                }
            };
        }

        //Create button for the particleType btnType
        function Button(btnType) {

            this.buttonSize = 36; //Button size is 36x36 for prettier math
            this.borderThickness = 6;

            this.buttonType = btnType; //Button is aware of its type

            //Place button at the bottom right corner, account for button border
            //this.x = cvs.height - (buttonSize * buttonID) - (borderThickness/2);
            //this.y = cvs.width - buttonSize - (borderThickness/2);

            //Or add more spacing than just the width of the border, to make the button row "float"
            this.x = cvs.height - (this.buttonSize * buttonID) - 12;
            this.y = cvs.width - this.buttonSize - 12;

            buttons[buttonID] = this;
            this.id = buttonID++;

            var buttonColor = "";

            if (btnType == "Snow") {
                buttonColor = "#ffffff";
            } else if (btnType == "Rain") {
                buttonColor = "#3439bc"
            }

            this.draw = function () {

                ctx.fillStyle = buttonColor;
                ctx.fillRect(this.x, this.y, this.buttonSize, this.buttonSize);

                ctx.beginPath();
                ctx.lineWidth = this.borderThickness;
                ctx.strokeStyle = "#4c4a4a";
                ctx.rect(this.x, this.y, this.buttonSize, this.buttonSize);
                ctx.stroke();
            };

            this.clicked = function () {
                console.log("clicked ");
            }

        }

        new Button("Snow");
        new Button("Rain");
        //new Button("Bees"); //NOT THE BEES

        //Draw canvas
        setInterval(function () {

            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, cvs.width, cvs.height);

            //Replace with particle density value

            if (Math.random() > 1 - (density.value / 100)) {
                new Particle();
            }

            for (var p in particles) {
                particles[p].draw();
            }

            for (var b in buttons) {
                buttons[b].draw();
            }

        }, 30);

        cvs.addEventListener('click', function (evt) {
            var loc = { x: 0, y: 0 };

            var rect = cvs.getBoundingClientRect();
            loc.x = event.clientX - rect.left;
            loc.y = event.clientY;

            var clicked = getClickedObject(loc);

            if (clicked == "Canvas") {
                //pause
            }

            particleType = clicked;
            for (var p in particles) {
                if (particles[p].particleType !== clicked) {
                    delete particles[p];
                }
            }

        });

        function getClickedObject(loc) {
            for (var b in buttons) {

                //Simplifying for readability
                var btn = buttons[b];
                var btnSize = btn.buttonSize;
                //var btnSize = btn.buttonSize + (btn.borderThickness / 2); //Include border in clickable button space

                if ((loc.x >= btn.x && loc.x < btn.x + btnSize) && (loc.y >= btn.y && loc.y < btn.y + btnSize)) {
                    return btn.buttonType;
                }
            }

            //If canvas was clicked, but not a button
            return "Canvas";
        }

    </script>



</body>
</html>
